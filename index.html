<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue Implementation Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(to bottom right, #eff6ff, #faf5ff);
            min-height: 100vh;
            padding: 1rem;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        
        h1 {
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 2rem;
        }
        
        .btn-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }
        
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-array { background: #2563eb; color: white; }
        .btn-array.active { box-shadow: 0 8px 16px rgba(37, 99, 235, 0.4); }
        .btn-linked { background: white; color: #374151; }
        .btn-linked.active { background: #16a34a; color: white; box-shadow: 0 8px 16px rgba(22, 163, 74, 0.4); }
        .btn-code { background: #9333ea; color: white; }
        .btn-enqueue { background: #16a34a; color: white; }
        .btn-dequeue { background: #dc2626; color: white; }
        .btn-peek { background: #2563eb; color: white; }
        .btn-isempty { background: #9333ea; color: white; }
        .btn-reset { background: #4b5563; color: white; }
        
        .card {
            background: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .card h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 1rem;
        }
        
        .visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 8rem;
            overflow-x: auto;
            padding-bottom: 1rem;
        }
        
        .queue-container {
            display: flex;
            gap: 0.5rem;
        }
        
        .queue-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .cell-box {
            width: 4rem;
            height: 4rem;
            border: 2px solid #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            font-weight: 600;
            background: #f3f4f6;
            transition: all 0.3s;
        }
        
        .cell-box.filled {
            background: #dbeafe;
            border-color: #2563eb;
        }
        
        .cell-box.highlight {
            background: #fef08a;
            border-color: #eab308;
            transform: scale(1.1);
            animation: pulse 0.5s ease-in-out;
        }
        
        .cell-index {
            font-size: 0.75rem;
            color: #4b5563;
            margin-top: 0.25rem;
        }
        
        .cell-label {
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 0.25rem;
        }
        
        .label-front { color: #16a34a; }
        .label-rear { color: #dc2626; }
        
        .linked-node {
            display: flex;
            align-items: center;
        }
        
        .node-box {
            width: 5rem;
            height: 4rem;
            border: 2px solid #16a34a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            font-weight: 600;
            background: #dcfce7;
            transition: all 0.3s;
        }
        
        .node-box.highlight {
            background: #fef08a;
            border-color: #eab308;
            transform: scale(1.1);
        }
        
        .arrow {
            margin: 0 0.5rem;
            font-size: 1.5rem;
            color: #9ca3af;
        }
        
        .empty-queue {
            color: #9ca3af;
            font-size: 1.125rem;
        }
        
        .variables-tracker {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 0.75rem;
            padding: 1.5rem;
            color: white;
            margin-bottom: 1.5rem;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .variables-tracker h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .variables-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .variable-item {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }
        
        .variable-item:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        
        .variable-item.changed {
            animation: highlight-change 0.6s ease-in-out;
        }
        
        @keyframes highlight-change {
            0%, 100% { background: rgba(255, 255, 255, 0.15); }
            50% { background: rgba(254, 240, 138, 0.5); transform: scale(1.05); }
        }
        
        .variable-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.9;
            margin-bottom: 0.25rem;
        }
        
        .variable-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            justify-content: center;
        }
        
        input {
            padding: 0.5rem 1rem;
            border: 2px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        
        input:focus {
            outline: none;
            border-color: #2563eb;
        }
        
        .message {
            text-align: center;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
        }
        
        .message.success {
            background: #d1fae5;
            color: #047857;
        }
        
        .message.error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .message.hidden {
            display: none;
        }
        
        .code-section {
            background: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .code-section.hidden {
            display: none;
        }
        
        .code-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .code-tab {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            background: #e5e7eb;
            border: none;
            cursor: pointer;
        }
        
        .code-tab.active {
            background: #2563eb;
            color: white;
        }
        
        pre {
            background: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        
        .complexity-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }
        
        @media (min-width: 768px) {
            .complexity-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .complexity-card {
            border: 2px solid;
            border-radius: 0.5rem;
            padding: 1rem;
        }
        
        .complexity-card.array {
            border-color: #bfdbfe;
        }
        
        .complexity-card.linked {
            border-color: #bbf7d0;
        }
        
        .complexity-card h4 {
            font-weight: bold;
            margin-bottom: 0.75rem;
        }
        
        .complexity-card.array h4 {
            color: #1d4ed8;
        }
        
        .complexity-card.linked h4 {
            color: #15803d;
        }
        
        .complexity-list {
            list-style: none;
        }
        
        .complexity-list li {
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .problem {
            color: #dc2626;
            margin-top: 0.75rem;
        }
        
        .advantage {
            color: #16a34a;
            margin-top: 0.75rem;
        }
        
        .best-impl {
            margin-top: 1.5rem;
            padding: 1rem;
            background: #fefce8;
            border: 2px solid #fde047;
            border-radius: 0.5rem;
        }
        
        .best-impl h4 {
            font-weight: bold;
            color: #854d0e;
            margin-bottom: 0.5rem;
        }
        
        .best-impl p {
            font-size: 0.875rem;
            color: #374151;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Queue Implementation Visualizer</h1>
        
        <div class="btn-group">
            <button onclick="switchType('array')" id="arrayBtn" class="btn-array active">
                Array Implementation
            </button>
            <button onclick="switchType('linked')" id="linkedBtn" class="btn-linked">
                Linked List Implementation
            </button>
            <button onclick="toggleCode()" class="btn-code">
                <span id="codeIcon">üìù</span>
                <span id="codeText">Show</span> Java Code
            </button>
        </div>

        <div class="variables-tracker">
            <h3>
                <span>üìä</span>
                <span>Queue State Variables</span>
            </h3>
            <div class="variables-grid" id="variablesGrid"></div>
        </div>

        <div class="card">
            <h2 id="queueTitle">Array-Based Queue</h2>
            <div class="visualization">
                <div id="visualization" class="queue-container"></div>
            </div>
        </div>

        <div class="card">
            <div class="controls">
                <input type="text" id="inputValue" placeholder="Enter value">
                <button onclick="enqueue()" class="btn-enqueue">‚ûï Enqueue</button>
                <button onclick="dequeue()" class="btn-dequeue">‚ûñ Dequeue</button>
                <button onclick="peek()" class="btn-peek">üëÅÔ∏è Peek</button>
                <button onclick="isEmpty()" class="btn-isempty">‚ùì isEmpty</button>
                <button onclick="reset()" class="btn-reset">üîÑ Reset</button>
            </div>
        </div>

        <div id="message" class="message hidden"></div>

        <div id="codeSection" class="code-section hidden">
            <h2>Java Implementation Code</h2>
            <div class="code-tabs">
                <button onclick="showCode('array')" id="arrayCodeBtn" class="code-tab active">
                    Array Code
                </button>
                <button onclick="showCode('linked')" id="linkedCodeBtn" class="code-tab">
                    Linked List Code
                </button>
                <button onclick="showCode('circular')" id="circularCodeBtn" class="code-tab">
                    Circular Queue Code
                </button>
            </div>
            <pre><code id="codeDisplay"></code></pre>
        </div>

        <div class="card">
            <h2>Time Complexity Analysis</h2>
            <div class="complexity-grid">
                <div class="complexity-card array">
                    <h4>Array Implementation</h4>
                    <ul class="complexity-list">
                        <li><strong>Enqueue:</strong> O(1) - Add to rear</li>
                        <li><strong>Dequeue:</strong> O(1) - Remove from front</li>
                        <li><strong>Peek:</strong> O(1) - Access front element</li>
                        <li><strong>isEmpty:</strong> O(1) - Check pointers</li>
                        <li class="problem"><strong>Problem:</strong> Fixed size, wasted space after dequeues</li>
                    </ul>
                </div>
                <div class="complexity-card linked">
                    <h4>Linked List Implementation</h4>
                    <ul class="complexity-list">
                        <li><strong>Enqueue:</strong> O(1) - Add to rear</li>
                        <li><strong>Dequeue:</strong> O(1) - Remove from front</li>
                        <li><strong>Peek:</strong> O(1) - Access front node</li>
                        <li><strong>isEmpty:</strong> O(1) - Check if head is null</li>
                        <li class="advantage"><strong>Advantage:</strong> Dynamic size, no wasted space</li>
                    </ul>
                </div>
            </div>
            <div class="best-impl">
                <h4>Best Implementation?</h4>
                <p>
                    <strong>Linked List is generally better</strong> for queues because it has dynamic size and no wasted space. 
                    Array implementation suffers from the problem shown above - space at the beginning becomes unusable after dequeues. 
                    A <strong>Circular Queue</strong> (array-based) solves this by wrapping around, but Linked List remains the most flexible choice.
                </p>
            </div>
        </div>
    </div>

    <script>
        let queueType = 'array';
        let queue = [];
        let arraySize = 8;
        let front = 0;
        let rear = -1;
        let highlightIndex = -1;
        let showingCode = false;
        let currentCodeView = 'array';
        let previousVariables = {};

        const codes = {
            array: `// Array-Based Queue Implementation
public class ArrayQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }
    
    // Enqueue: Add element to rear - O(1)
    public void enqueue(int item) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        rear++;
        queue[rear] = item;
        size++;
        System.out.println("Enqueued: " + item);
    }
    
    // Dequeue: Remove element from front - O(1)
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        int item = queue[front];
        front++;
        size--;
        System.out.println("Dequeued: " + item);
        return item;
    }
    
    // Peek: View front element - O(1)
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        return queue[front];
    }
    
    // Check if empty - O(1)
    public boolean isEmpty() {
        return size == 0;
    }
    
    // Check if full - O(1)
    public boolean isFull() {
        return rear == capacity - 1;
    }
    
    public int size() {
        return size;
    }
}`,
            linked: `// Linked List Queue Implementation
public class LinkedQueue {
    // Node class for linked list
    private class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node front;
    private Node rear;
    private int size;
    
    public LinkedQueue() {
        front = null;
        rear = null;
        size = 0;
    }
    
    // Enqueue: Add element to rear - O(1)
    public void enqueue(int item) {
        Node newNode = new Node(item);
        
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        size++;
        System.out.println("Enqueued: " + item);
    }
    
    // Dequeue: Remove element from front - O(1)
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        
        int item = front.data;
        front = front.next;
        
        if (front == null) {
            rear = null;
        }
        
        size--;
        System.out.println("Dequeued: " + item);
        return item;
    }
    
    // Peek: View front element - O(1)
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        return front.data;
    }
    
    // Check if empty - O(1)
    public boolean isEmpty() {
        return front == null;
    }
    
    public int size() {
        return size;
    }
}`,
            circular: `// Circular Queue
public class CircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }
    
    // Enqueue with circular wrapping - O(1)
    public void enqueue(int item) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        rear = (rear + 1) % capacity;
        queue[rear] = item;
        size++;
    }
    
    // Dequeue with circular wrapping - O(1)
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        int item = queue[front];
        front = (front + 1) % capacity;
        size--;
        return item;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}`
        };

        function updateVariables() {
            const gridEl = document.getElementById('variablesGrid');
            const currentVariables = {};
            
            if (queueType === 'array') {
                currentVariables.front = front;
                currentVariables.rear = rear;
                currentVariables.capacity = arraySize;
                currentVariables.size = front > rear || rear < 0 ? 0 : (rear - front + 1);
                currentVariables.isEmpty = front > rear || rear < 0;
                currentVariables.isFull = rear >= arraySize - 1;
                
                gridEl.innerHTML = `
                    <div class="variable-item ${previousVariables.front !== front ? 'changed' : ''}" id="var-front">
                        <div class="variable-label">front</div>
                        <div class="variable-value">${front}</div>
                    </div>
                    <div class="variable-item ${previousVariables.rear !== rear ? 'changed' : ''}" id="var-rear">
                        <div class="variable-label">rear</div>
                        <div class="variable-value">${rear}</div>
                    </div>
                    <div class="variable-item" id="var-capacity">
                        <div class="variable-label">capacity</div>
                        <div class="variable-value">${arraySize}</div>
                    </div>
                    <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}" id="var-size">
                        <div class="variable-label">size</div>
                        <div class="variable-value">${currentVariables.size}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}" id="var-empty">
                        <div class="variable-label">isEmpty</div>
                        <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isFull !== currentVariables.isFull ? 'changed' : ''}" id="var-full">
                        <div class="variable-label">isFull</div>
                        <div class="variable-value">${currentVariables.isFull ? '‚úì' : '‚úó'}</div>
                    </div>
                `;
            } else {
                currentVariables.size = queue.length;
                currentVariables.isEmpty = queue.length === 0;
                currentVariables.frontData = queue.length > 0 ? queue[0] : 'null';
                currentVariables.rearData = queue.length > 0 ? queue[queue.length - 1] : 'null';
                
                gridEl.innerHTML = `
                    <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}" id="var-size">
                        <div class="variable-label">size</div>
                        <div class="variable-value">${currentVariables.size}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}" id="var-empty">
                        <div class="variable-label">isEmpty</div>
                        <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
                    </div>
                    <div class="variable-item ${previousVariables.frontData !== currentVariables.frontData ? 'changed' : ''}" id="var-front-data">
                        <div class="variable-label">front.data</div>
                        <div class="variable-value">${currentVariables.frontData}</div>
                    </div>
                    <div class="variable-item ${previousVariables.rearData !== currentVariables.rearData ? 'changed' : ''}" id="var-rear-data">
                        <div class="variable-label">rear.data</div>
                        <div class="variable-value">${currentVariables.rearData}</div>
                    </div>
                `;
            }
            
            previousVariables = {...currentVariables};
        }

        function showMessage(msg, isError = false) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = msg;
            messageEl.className = `message ${isError ? 'error' : 'success'}`;
            setTimeout(() => messageEl.classList.add('hidden'), 3000);
        }

        function switchType(type) {
            queueType = type;
            reset();
            
            const arrayBtn = document.getElementById('arrayBtn');
            const linkedBtn = document.getElementById('linkedBtn');
            
            if (type === 'array') {
                arrayBtn.className = 'btn-array active';
                linkedBtn.className = 'btn-linked';
                document.getElementById('queueTitle').textContent = 'Array-Based Queue';
            } else {
                arrayBtn.className = 'btn-array';
                linkedBtn.className = 'btn-linked active';
                document.getElementById('queueTitle').textContent = 'Linked List Queue';
            }
            
            render();
            updateVariables();
        }

        function toggleCode() {
            showingCode = !showingCode;
            const codeSection = document.getElementById('codeSection');
            codeSection.classList.toggle('hidden');
            document.getElementById('codeText').textContent = showingCode ? 'Hide' : 'Show';
            if (showingCode) {
                showCode(currentCodeView);
            }
        }

        function showCode(type) {
            currentCodeView = type;
            document.getElementById('codeDisplay').textContent = codes[type];
            
            document.getElementById('arrayCodeBtn').className = 'code-tab';
            document.getElementById('linkedCodeBtn').className = 'code-tab';
            document.getElementById('circularCodeBtn').className = 'code-tab';
            document.getElementById(type + 'CodeBtn').className = 'code-tab active';
        }

        async function enqueue() {
            const input = document.getElementById('inputValue');
            const value = input.value.trim();
            
            if (!value) {
                showMessage('Please enter a value', true);
                return;
            }

            if (queueType === 'array') {
                if (rear >= arraySize - 1) {
                    showMessage('Queue is full!', true);
                    return;
                }
                highlightIndex = rear + 1;
                render();
                await sleep(500);
                
                queue[rear + 1] = value;
                rear++;
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Enqueued: ${value}`);
            } else {
                highlightIndex = queue.length;
                render();
                await sleep(500);
                
                queue.push(value);
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Enqueued: ${value}`);
            }
            input.value = '';
        }

        async function dequeue() {
            if (queueType === 'array') {
                if (front > rear || rear < 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = front;
                render();
                await sleep(500);
                
                const value = queue[front];
                queue[front] = undefined;
                front++;
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Dequeued: ${value}`);
            } else {
                if (queue.length === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = 0;
                render();
                await sleep(500);
                
                const value = queue.shift();
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Dequeued: ${value}`);
            }
        }

        async function peek() {
            if (queueType === 'array') {
                if (front > rear || rear < 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = front;
                render();
                showMessage(`Front element: ${queue[front]}`);
                await sleep(1000);
                highlightIndex = -1;
                render();
            } else {
                if (queue.length === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = 0;
                render();
                showMessage(`Front element: ${queue[0]}`);
                await sleep(1000);
                highlightIndex = -1;
                render();
            }
        }

        function isEmpty() {
            if (queueType === 'array') {
                const empty = front > rear || rear < 0;
                showMessage(empty ? 'Queue is empty: true' : 'Queue is empty: false');
            } else {
                showMessage(queue.length === 0 ? 'Queue is empty: true' : 'Queue is empty: false');
            }
        }

        function reset() {
            queue = [];
            front = 0;
            rear = -1;
            highlightIndex = -1;
            previousVariables = {};
            document.getElementById('inputValue').value = '';
            render();
            updateVariables();
        }

        function render() {
            const viz = document.getElementById('visualization');
            
            if (queueType === 'array') {
                let html = '';
                for (let i = 0; i < arraySize; i++) {
                    const isFront = i === front && front <= rear && rear >= 0;
                    const isRear = i === rear && rear >= 0;
                    const isHighlight = i === highlightIndex;
                    
                    html += `
                        <div class="queue-cell">
                            <div class="cell-box ${queue[i] !== undefined ? 'filled' : ''} ${isHighlight ? 'highlight' : ''}">
                                ${queue[i] !== undefined ? queue[i] : ''}
                            </div>
                            <div class="cell-index">${i}</div>
                            ${isFront ? '<div class="cell-label label-front">FRONT</div>' : ''}
                            ${isRear && !isFront ? '<div class="cell-label label-rear">REAR</div>' : ''}
                            ${isFront && isRear ? '<div class="cell-label label-rear">FRONT/REAR</div>' : ''}
                        </div>
                    `;
                }
                viz.innerHTML = html;
            } else {
                if (queue.length === 0) {
                    viz.innerHTML = '<div class="empty-queue">Empty Queue</div>';
                } else {
                    let html = '';
                    queue.forEach((item, index) => {
                        const isHighlight = index === highlightIndex;
                        html += `
                            <div class="linked-node">
                                <div class="queue-cell">
                                    <div class="node-box ${isHighlight ? 'highlight' : ''}">
                                        ${item}
                                    </div>
                                    ${index === 0 ? '<div class="cell-label label-front">FRONT</div>' : ''}
                                    ${index === queue.length - 1 ? '<div class="cell-label label-rear">REAR</div>' : ''}
                                </div>
                                ${index < queue.length - 1 ? '<div class="arrow">‚Üí</div>' : ''}
                            </div>
                        `;
                    });
                    viz.innerHTML = html;
                }
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        render();
        updateVariables();
    </script>
</body>
</html>
