<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue Implementation Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(to bottom right, #eff6ff, #faf5ff);
            min-height: 100vh;
            padding: 1rem;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        
        h1 {
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 2rem;
        }
        
        .btn-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }
        
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-array { background: #2563eb; color: white; }
        .btn-array.active { box-shadow: 0 8px 16px rgba(37, 99, 235, 0.4); }
        .btn-circular { background: white; color: #374151; }
        .btn-circular.active { background: #f97316; color: white; box-shadow: 0 8px 16px rgba(249, 115, 22, 0.4); }
        .btn-linked { background: white; color: #374151; }
        .btn-linked.active { background: #16a34a; color: white; box-shadow: 0 8px 16px rgba(22, 163, 74, 0.4); }
        .btn-code { background: #9333ea; color: white; }
        .btn-enqueue { background: #16a34a; color: white; }
        .btn-dequeue { background: #dc2626; color: white; }
        .btn-peek { background: #2563eb; color: white; }
        .btn-isempty { background: #9333ea; color: white; }
        .btn-reset { background: #4b5563; color: white; }
        
        .card {
            background: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .card h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 1rem;
        }
        
        .visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 8rem;
            overflow-x: auto;
            padding-bottom: 1rem;
        }
        
        .queue-container {
            display: flex;
            gap: 0.5rem;
        }
        
        .circular-container {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 2rem auto;
        }
        
        .circular-cell {
            position: absolute;
            width: 70px;
            height: 70px;
            transform-origin: center;
        }
        
        .circular-box {
            width: 100%;
            height: 100%;
            border: 3px solid #f97316;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            font-weight: 600;
            background: #fff;
            border-radius: 0.5rem;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .circular-box.filled {
            background: #fed7aa;
            border-color: #f97316;
        }
        
        .circular-box.highlight {
            background: #fef08a;
            border-color: #eab308;
            transform: scale(1.15);
            animation: pulse 0.5s ease-in-out;
            box-shadow: 0 4px 16px rgba(234, 179, 8, 0.5);
        }
        
        .circular-index {
            font-size: 0.7rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        
        .circular-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            white-space: nowrap;
        }
        
        .label-front-circular {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .label-rear-circular {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .wrap-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #f97316;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .wrap-indicator.show {
            opacity: 1;
            animation: rotate-wrap 1s ease-in-out;
        }
        
        @keyframes rotate-wrap {
            0% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            50% { transform: translate(-50%, -50%) rotate(180deg) scale(1.3); }
            100% { transform: translate(-50%, -50%) rotate(360deg) scale(1); }
        }
        
        .queue-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .cell-box {
            width: 4rem;
            height: 4rem;
            border: 2px solid #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            font-weight: 600;
            background: #f3f4f6;
            transition: all 0.3s;
        }
        
        .cell-box.filled {
            background: #dbeafe;
            border-color: #2563eb;
        }
        
        .cell-box.highlight {
            background: #fef08a;
            border-color: #eab308;
            transform: scale(1.1);
            animation: pulse 0.5s ease-in-out;
        }
        
        .cell-index {
            font-size: 0.75rem;
            color: #4b5563;
            margin-top: 0.25rem;
        }
        
        .cell-label {
            font-size: 0.75rem;
            font-weight: bold;
            margin-top: 0.25rem;
        }
        
        .label-front { color: #16a34a; }
        .label-rear { color: #dc2626; }
        
        .linked-node {
            display: flex;
            align-items: center;
        }
        
        .node-box {
            width: 5rem;
            height: 4rem;
            border: 2px solid #16a34a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            font-weight: 600;
            background: #dcfce7;
            transition: all 0.3s;
        }
        
        .node-box.highlight {
            background: #fef08a;
            border-color: #eab308;
            transform: scale(1.1);
        }
        
        .arrow {
            margin: 0 0.5rem;
            font-size: 1.5rem;
            color: #9ca3af;
        }
        
        .empty-queue {
            color: #9ca3af;
            font-size: 1.125rem;
        }
        
        .variables-tracker {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 0.75rem;
            padding: 1.5rem;
            color: white;
            margin-bottom: 1.5rem;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .variables-tracker h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .variables-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .variable-item {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }
        
        .variable-item:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        
        .variable-item.changed {
            animation: highlight-change 0.6s ease-in-out;
        }
        
        @keyframes highlight-change {
            0%, 100% { background: rgba(255, 255, 255, 0.15); }
            50% { background: rgba(254, 240, 138, 0.5); transform: scale(1.05); }
        }
        
        .variable-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.9;
            margin-bottom: 0.25rem;
        }
        
        .variable-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        
        .explanation-box {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        .explanation-box h4 {
            color: #92400e;
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .explanation-box p {
            color: #78350f;
            font-size: 0.875rem;
            line-height: 1.6;
        }
        
        .formula {
            background: #fff;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #1f2937;
            margin: 0.5rem 0;
            display: inline-block;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            justify-content: center;
        }
        
        input {
            padding: 0.5rem 1rem;
            border: 2px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        
        input:focus {
            outline: none;
            border-color: #2563eb;
        }
        
        .message {
            text-align: center;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
        }
        
        .message.success {
            background: #d1fae5;
            color: #047857;
        }
        
        .message.error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .message.hidden {
            display: none;
        }
        
        .code-section {
            background: white;
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .code-section.hidden {
            display: none;
        }
        
        .code-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .code-tab {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            background: #e5e7eb;
            border: none;
            cursor: pointer;
        }
        
        .code-tab.active {
            background: #2563eb;
            color: white;
        }
        
        pre {
            background: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        
        .complexity-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }
        
        @media (min-width: 768px) {
            .complexity-grid {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }
        
        .complexity-card {
            border: 2px solid;
            border-radius: 0.5rem;
            padding: 1rem;
        }
        
        .complexity-card.array {
            border-color: #bfdbfe;
        }
        
        .complexity-card.circular {
            border-color: #fed7aa;
        }
        
        .complexity-card.linked {
            border-color: #bbf7d0;
        }
        
        .complexity-card h4 {
            font-weight: bold;
            margin-bottom: 0.75rem;
        }
        
        .complexity-card.array h4 {
            color: #1d4ed8;
        }
        
        .complexity-card.circular h4 {
            color: #c2410c;
        }
        
        .complexity-card.linked h4 {
            color: #15803d;
        }
        
        .complexity-list {
            list-style: none;
        }
        
        .complexity-list li {
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .problem {
            color: #dc2626;
            margin-top: 0.75rem;
        }
        
        .advantage {
            color: #16a34a;
            margin-top: 0.75rem;
        }
        
        .best-impl {
            margin-top: 1.5rem;
            padding: 1rem;
            background: #fefce8;
            border: 2px solid #fde047;
            border-radius: 0.5rem;
        }
        
        .best-impl h4 {
            font-weight: bold;
            color: #854d0e;
            margin-bottom: 0.5rem;
        }
        
        .best-impl p {
            font-size: 0.875rem;
            color: #374151;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Queue Implementation Visualizer</h1>
        
        <div class="btn-group">
            <button onclick="switchType('array')" id="arrayBtn" class="btn-array active">
                Array Queue
            </button>
            <button onclick="switchType('circular')" id="circularBtn" class="btn-circular">
                üîÑ Circular Queue
            </button>
            <button onclick="switchType('linked')" id="linkedBtn" class="btn-linked">
                Linked List Queue
            </button>
            <button onclick="toggleCode()" class="btn-code">
                <span id="codeIcon">üìù</span>
                <span id="codeText">Show</span> Java Code
            </button>
        </div>

        <div class="variables-tracker">
            <h3>
                <span>üìä</span>
                <span>Queue State Variables</span>
            </h3>
            <div class="variables-grid" id="variablesGrid"></div>
        </div>

        <div class="card">
            <h2 id="queueTitle">Array-Based Queue</h2>
            <div class="visualization">
                <div id="visualization" class="queue-container"></div>
            </div>
            
            <div id="circularExplanation" class="explanation-box" style="display: none;">
                <h4>üîÑ Why Modulo (%) Operator?</h4>
                <p>
                    The modulo operator makes the array "wrap around" like a circle:<br>
                    <span class="formula">rear = (rear + 1) % capacity</span><br>
                    <strong>Example:</strong> If capacity = 8 and rear = 7, then (7 + 1) % 8 = 0<br>
                    This means after reaching the end (index 7), it wraps back to the beginning (index 0)!<br>
                    <strong>Watch the circular visualization above</strong> - see how front and rear wrap around the circle! üéØ
                </p>
            </div>
        </div>

        <div class="card">
            <div class="controls">
                <input type="text" id="inputValue" placeholder="Enter value">
                <button onclick="enqueue()" class="btn-enqueue">‚ûï Enqueue</button>
                <button onclick="dequeue()" class="btn-dequeue">‚ûñ Dequeue</button>
                <button onclick="peek()" class="btn-peek">üëÅÔ∏è Peek</button>
                <button onclick="isEmpty()" class="btn-isempty">‚ùì isEmpty</button>
                <button onclick="reset()" class="btn-reset">üîÑ Reset</button>
            </div>
        </div>

        <div id="message" class="message hidden"></div>

        <div id="codeSection" class="code-section hidden">
            <h2>Java Implementation Code</h2>
            <div class="code-tabs">
                <button onclick="showCode('array')" id="arrayCodeBtn" class="code-tab active">
                    Array Code
                </button>
                <button onclick="showCode('circular')" id="circularCodeBtn" class="code-tab">
                    Circular Queue Code
                </button>
                <button onclick="showCode('linked')" id="linkedCodeBtn" class="code-tab">
                    Linked List Code
                </button>
            </div>
            <pre><code id="codeDisplay"></code></pre>
        </div>

        <div class="card">
            <h2>Time Complexity Analysis</h2>
            <div class="complexity-grid">
                <div class="complexity-card array">
                    <h4>Array Implementation</h4>
                    <ul class="complexity-list">
                        <li><strong>Enqueue:</strong> O(1)</li>
                        <li><strong>Dequeue:</strong> O(1)</li>
                        <li><strong>Peek:</strong> O(1)</li>
                        <li><strong>isEmpty:</strong> O(1)</li>
                        <li class="problem"><strong>Problem:</strong> Fixed size, wasted space</li>
                    </ul>
                </div>
                <div class="complexity-card circular">
                    <h4>Circular Queue</h4>
                    <ul class="complexity-list">
                        <li><strong>Enqueue:</strong> O(1)</li>
                        <li><strong>Dequeue:</strong> O(1)</li>
                        <li><strong>Peek:</strong> O(1)</li>
                        <li><strong>isEmpty:</strong> O(1)</li>
                        <li class="advantage"><strong>Fix:</strong> Reuses space by wrapping!</li>
                    </ul>
                </div>
                <div class="complexity-card linked">
                    <h4>Linked List Queue</h4>
                    <ul class="complexity-list">
                        <li><strong>Enqueue:</strong> O(1)</li>
                        <li><strong>Dequeue:</strong> O(1)</li>
                        <li><strong>Peek:</strong> O(1)</li>
                        <li><strong>isEmpty:</strong> O(1)</li>
                        <li class="advantage"><strong>Best:</strong> Dynamic, no waste</li>
                    </ul>
                </div>
            </div>
            <div class="best-impl">
                <h4>Which Implementation Should You Use?</h4>
                <p>
                    <strong>Circular Queue</strong> solves the array wasted space problem elegantly using the modulo operator to wrap indices around. 
                    However, <strong>Linked List is still the best choice</strong> for most real-world applications because it's truly dynamic (grows/shrinks as needed) and conceptually simpler.
                    Use Circular Queue when you need fixed-size, cache-friendly memory with no waste.
                </p>
            </div>
        </div>
    </div>

    <script>
        let queueType = 'array';
        let queue = [];
        let arraySize = 8;
        let front = 0;
        let rear = -1;
        let size = 0;
        let highlightIndex = -1;
        let showingCode = false;
        let currentCodeView = 'array';
        let previousVariables = {};
        let showWrapIndicator = false;

        const codes = {
            array: `// Array-Based Queue Implementation
public class ArrayQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }
    
    public void enqueue(int item) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        rear++;
        queue[rear] = item;
        size++;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        int item = queue[front];
        front++;
        size--;
        return item;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        return queue[front];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return rear == capacity - 1;
    }
}`,
            circular: `// Circular Queue - Solves Space Waste!
public class CircularQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }
    
    // MODULO makes it wrap around!
    public void enqueue(int item) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        // Key: (rear + 1) % capacity wraps to 0
        rear = (rear + 1) % capacity;
        queue[rear] = item;
        size++;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        int item = queue[front];
        // Key: (front + 1) % capacity wraps to 0
        front = (front + 1) % capacity;
        size--;
        return item;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        return queue[front];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
    
    // Example of wrapping:
    // If capacity = 8, rear = 7
    // Then (7 + 1) % 8 = 0 (wraps to start!)
}`,
            linked: `// Linked List Queue Implementation
public class LinkedQueue {
    private class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node front;
    private Node rear;
    private int size;
    
    public LinkedQueue() {
        front = null;
        rear = null;
        size = 0;
    }
    
    public void enqueue(int item) {
        Node newNode = new Node(item);
        
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        size++;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        
        int item = front.data;
        front = front.next;
        
        if (front == null) {
            rear = null;
        }
        
        size--;
        return item;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        return front.data;
    }
    
    public boolean isEmpty() {
        return front == null;
    }
    
    public int size() {
        return size;
    }
}`
        };

        function updateVariables() {
            const gridEl = document.getElementById('variablesGrid');
            const currentVariables = {};
            
            if (queueType === 'array') {
                currentVariables.front = front;
                currentVariables.rear = rear;
                currentVariables.capacity = arraySize;
                currentVariables.size = size;
                currentVariables.isEmpty = size === 0;
                currentVariables.isFull = rear >= arraySize - 1;
                
                gridEl.innerHTML = `
                    <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}">
                        <div class="variable-label">size</div>
                        <div class="variable-value">${currentVariables.size}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}">
                        <div class="variable-label">isEmpty</div>
                        <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isFull !== currentVariables.isFull ? 'changed' : ''}">
                        <div class="variable-label">isFull</div>
                        <div class="variable-value">${currentVariables.isFull ? '‚úì' : '‚úó'}</div>
                    </div>
                `;
            } else {
                currentVariables.size = queue.length;
                currentVariables.isEmpty = queue.length === 0;
                currentVariables.frontData = queue.length > 0 ? queue[0] : 'null';
                currentVariables.rearData = queue.length > 0 ? queue[queue.length - 1] : 'null';
                
                gridEl.innerHTML = `
                    <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}">
                        <div class="variable-label">size</div>
                        <div class="variable-value">${currentVariables.size}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}">
                        <div class="variable-label">isEmpty</div>
                        <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
                    </div>
                    <div class="variable-item ${previousVariables.frontData !== currentVariables.frontData ? 'changed' : ''}">
                        <div class="variable-label">front.data</div>
                        <div class="variable-value">${currentVariables.frontData}</div>
                    </div>
                    <div class="variable-item ${previousVariables.rearData !== currentVariables.rearData ? 'changed' : ''}">
                        <div class="variable-label">rear.data</div>
                        <div class="variable-value">${currentVariables.rearData}</div>
                    </div>
                `;
            }
            
            previousVariables = {...currentVariables};
        }

        function showMessage(msg, isError = false) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = msg;
            messageEl.className = `message ${isError ? 'error' : 'success'}`;
            setTimeout(() => messageEl.classList.add('hidden'), 3000);
        }

        function switchType(type) {
            queueType = type;
            reset();
            
            const arrayBtn = document.getElementById('arrayBtn');
            const circularBtn = document.getElementById('circularBtn');
            const linkedBtn = document.getElementById('linkedBtn');
            const explanation = document.getElementById('circularExplanation');
            
            arrayBtn.className = 'btn-array';
            circularBtn.className = 'btn-circular';
            linkedBtn.className = 'btn-linked';
            
            if (type === 'array') {
                arrayBtn.className = 'btn-array active';
                document.getElementById('queueTitle').textContent = 'Array-Based Queue';
                explanation.style.display = 'none';
            } else if (type === 'circular') {
                circularBtn.className = 'btn-circular active';
                document.getElementById('queueTitle').textContent = 'Circular Queue (Watch the Wrap!)';
                explanation.style.display = 'block';
            } else {
                linkedBtn.className = 'btn-linked active';
                document.getElementById('queueTitle').textContent = 'Linked List Queue';
                explanation.style.display = 'none';
            }
            
            render();
            updateVariables();
        }

        function toggleCode() {
            showingCode = !showingCode;
            const codeSection = document.getElementById('codeSection');
            codeSection.classList.toggle('hidden');
            document.getElementById('codeText').textContent = showingCode ? 'Hide' : 'Show';
            if (showingCode) {
                showCode(currentCodeView);
            }
        }

        function showCode(type) {
            currentCodeView = type;
            document.getElementById('codeDisplay').textContent = codes[type];
            
            document.getElementById('arrayCodeBtn').className = 'code-tab';
            document.getElementById('circularCodeBtn').className = 'code-tab';
            document.getElementById('linkedCodeBtn').className = 'code-tab';
            document.getElementById(type + 'CodeBtn').className = 'code-tab active';
        }

        async function enqueue() {
            const input = document.getElementById('inputValue');
            const value = input.value.trim();
            
            if (!value) {
                showMessage('Please enter a value', true);
                return;
            }

            if (queueType === 'array') {
                if (rear >= arraySize - 1) {
                    showMessage('Queue is full!', true);
                    return;
                }
                highlightIndex = rear + 1;
                render();
                await sleep(500);
                
                queue[rear + 1] = value;
                rear++;
                size++;
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Enqueued: ${value}`);
            } else if (queueType === 'circular') {
                if (size >= arraySize) {
                    showMessage('Queue is full!', true);
                    return;
                }
                
                const newRear = (rear + 1) % arraySize;
                
                if (newRear < rear) {
                    showWrapIndicator = true;
                    render();
                    await sleep(800);
                    showWrapIndicator = false;
                }
                
                highlightIndex = newRear;
                render();
                await sleep(500);
                
                queue[newRear] = value;
                rear = newRear;
                size++;
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Enqueued: ${value} at index ${rear} (wrapped!)`);
            } else {
                highlightIndex = queue.length;
                render();
                await sleep(500);
                
                queue.push(value);
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Enqueued: ${value}`);
            }
            input.value = '';
        }

        async function dequeue() {
            if (queueType === 'array') {
                if (size === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = front;
                render();
                await sleep(500);
                
                const value = queue[front];
                queue[front] = undefined;
                front++;
                size--;
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Dequeued: ${value}`);
            } else if (queueType === 'circular') {
                if (size === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = front;
                render();
                await sleep(500);
                
                const value = queue[front];
                queue[front] = undefined;
                
                const newFront = (front + 1) % arraySize;
                
                if (newFront < front) {
                    showWrapIndicator = true;
                    render();
                    await sleep(800);
                    showWrapIndicator = false;
                }
                
                front = newFront;
                size--;
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Dequeued: ${value}, front wrapped to ${front}`);
            } else {
                if (queue.length === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = 0;
                render();
                await sleep(500);
                
                const value = queue.shift();
                updateVariables();
                
                await sleep(500);
                highlightIndex = -1;
                render();
                showMessage(`Dequeued: ${value}`);
            }
        }

        async function peek() {
            if (queueType === 'array' || queueType === 'circular') {
                if (size === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = front;
                render();
                showMessage(`Front element: ${queue[front]}`);
                await sleep(1000);
                highlightIndex = -1;
                render();
            } else {
                if (queue.length === 0) {
                    showMessage('Queue is empty!', true);
                    return;
                }
                highlightIndex = 0;
                render();
                showMessage(`Front element: ${queue[0]}`);
                await sleep(1000);
                highlightIndex = -1;
                render();
            }
        }

        function isEmpty() {
            if (queueType === 'array' || queueType === 'circular') {
                showMessage(size === 0 ? 'Queue is empty: true' : 'Queue is empty: false');
            } else {
                showMessage(queue.length === 0 ? 'Queue is empty: true' : 'Queue is empty: false');
            }
        }

        function reset() {
            queue = [];
            front = 0;
            rear = -1;
            size = 0;
            highlightIndex = -1;
            previousVariables = {};
            showWrapIndicator = false;
            document.getElementById('inputValue').value = '';
            render();
            updateVariables();
        }

        function renderCircular() {
            const viz = document.getElementById('visualization');
            const radius = 120;
            const centerX = 160;
            const centerY = 160;
            
            let html = '<div class="circular-container">';
            
            html += `<div class="wrap-indicator ${showWrapIndicator ? 'show' : ''}">üîÑ</div>`;
            
            for (let i = 0; i < arraySize; i++) {
                const angle = (i / arraySize) * 2 * Math.PI - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle) - 35;
                const y = centerY + radius * Math.sin(angle) - 35;
                
                const isFront = i === front && size > 0;
                const isRear = i === rear && size > 0;
                const isHighlight = i === highlightIndex;
                
                html += `
                    <div class="circular-cell" style="left: ${x}px; top: ${y}px;">
                        ${isFront ? '<div class="circular-label label-front-circular">FRONT</div>' : ''}
                        ${isRear && !isFront ? '<div class="circular-label label-rear-circular">REAR</div>' : ''}
                        ${isFront && isRear ? '<div class="circular-label label-rear-circular">FRONT/REAR</div>' : ''}
                        <div class="circular-box ${queue[i] !== undefined ? 'filled' : ''} ${isHighlight ? 'highlight' : ''}">
                            <div>${queue[i] !== undefined ? queue[i] : ''}</div>
                            <div class="circular-index">[${i}]</div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            viz.innerHTML = html;
        }

        function render() {
            const viz = document.getElementById('visualization');
            
            if (queueType === 'circular') {
                renderCircular();
                return;
            }
            
            if (queueType === 'array') {
                let html = '';
                for (let i = 0; i < arraySize; i++) {
                    const isFront = i === front && size > 0;
                    const isRear = i === rear && size > 0;
                    const isHighlight = i === highlightIndex;
                    
                    html += `
                        <div class="queue-cell">
                            <div class="cell-box ${queue[i] !== undefined ? 'filled' : ''} ${isHighlight ? 'highlight' : ''}">
                                ${queue[i] !== undefined ? queue[i] : ''}
                            </div>
                            <div class="cell-index">${i}</div>
                            ${isFront ? '<div class="cell-label label-front">FRONT</div>' : ''}
                            ${isRear && !isFront ? '<div class="cell-label label-rear">REAR</div>' : ''}
                            ${isFront && isRear ? '<div class="cell-label label-rear">FRONT/REAR</div>' : ''}
                        </div>
                    `;
                }
                viz.innerHTML = html;
            } else {
                if (queue.length === 0) {
                    viz.innerHTML = '<div class="empty-queue">Empty Queue</div>';
                } else {
                    let html = '';
                    queue.forEach((item, index) => {
                        const isHighlight = index === highlightIndex;
                        html += `
                            <div class="linked-node">
                                <div class="queue-cell">
                                    <div class="node-box ${isHighlight ? 'highlight' : ''}">
                                        ${item}
                                    </div>
                                    ${index === 0 ? '<div class="cell-label label-front">FRONT</div>' : ''}
                                    ${index === queue.length - 1 ? '<div class="cell-label label-rear">REAR</div>' : ''}
                                </div>
                                ${index < queue.length - 1 ? '<div class="arrow">‚Üí</div>' : ''}
                            </div>
                        `;
                    });
                    viz.innerHTML = html;
                }
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        render();
        updateVariables();
    </script>
</body>
</html> class="variable-item ${previousVariables.front !== front ? 'changed' : ''}">
                        <div class="variable-label">front</div>
                        <div class="variable-value">${front}</div>
                    </div>
                    <div class="variable-item ${previousVariables.rear !== rear ? 'changed' : ''}">
                        <div class="variable-label">rear</div>
                        <div class="variable-value">${rear}</div>
                    </div>
                    <div class="variable-item">
                        <div class="variable-label">capacity</div>
                        <div class="variable-value">${arraySize}</div>
                    </div>
                    <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}">
                        <div class="variable-label">size</div>
                        <div class="variable-value">${currentVariables.size}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}">
                        <div class="variable-label">isEmpty</div>
                        <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
                    </div>
                    <div class="variable-item ${previousVariables.isFull !== currentVariables.isFull ? 'changed' : ''}">
                        <div class="variable-label">isFull</div>
                        <div class="variable-value">${currentVariables.isFull ? '‚úì' : '‚úó'}</div>
                    </div>
                `;
            } else if (queueType === 'circular') {
        currentVariables.front = front;
        currentVariables.rear = rear;
        currentVariables.capacity = arraySize;
        currentVariables.size = size;
        currentVariables.isEmpty = size === 0;
        currentVariables.isFull = size === arraySize;

        gridEl.innerHTML = `
            <div class="variable-item ${previousVariables.front !== front ? 'changed' : ''}">
                <div class="variable-label">front</div>
                <div class="variable-value">${front}</div>
            </div>
            <div class="variable-item ${previousVariables.rear !== rear ? 'changed' : ''}">
                <div class="variable-label">rear</div>
                <div class="variable-value">${rear}</div>
            </div>
            <div class="variable-item">
                <div class="variable-label">capacity</div>
                <div class="variable-value">${arraySize}</div>
            </div>
            <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}">
                <div class="variable-label">size</div>
                <div class="variable-value">${currentVariables.size}</div>
            </div>
            <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}">
                <div class="variable-label">isEmpty</div>
                <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
            </div>
            <div class="variable-item ${previousVariables.isFull !== currentVariables.isFull ? 'changed' : ''}">
                <div class="variable-label">isFull</div>
                <div class="variable-value">${currentVariables.isFull ? '‚úì' : '‚úó'}</div>
            </div>
        `;
    }

    else { // linked list
        currentVariables.size = queue.length;
        currentVariables.isEmpty = queue.length === 0;
        currentVariables.frontData = queue.length ? queue[0] : 'null';
        currentVariables.rearData = queue.length ? queue[queue.length - 1] : 'null';

        gridEl.innerHTML = `
            <div class="variable-item ${previousVariables.size !== currentVariables.size ? 'changed' : ''}">
                <div class="variable-label">size</div>
                <div class="variable-value">${currentVariables.size}</div>
            </div>
            <div class="variable-item ${previousVariables.isEmpty !== currentVariables.isEmpty ? 'changed' : ''}">
                <div class="variable-label">isEmpty</div>
                <div class="variable-value">${currentVariables.isEmpty ? '‚úì' : '‚úó'}</div>
            </div>
            <div class="variable-item ${previousVariables.frontData !== currentVariables.frontData ? 'changed' : ''}">
                <div class="variable-label">front.data</div>
                <div class="variable-value">${currentVariables.frontData}</div>
            </div>
            <div class="variable-item ${previousVariables.rearData !== currentVariables.rearData ? 'changed' : ''}">
                <div class="variable-label">rear.data</div>
                <div class="variable-value">${currentVariables.rearData}</div>
            </div>
        `;
    }

    previousVariables = { ...currentVariables };
}
